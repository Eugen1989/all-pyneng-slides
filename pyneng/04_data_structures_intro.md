# Python для сетевых инженеров 

---
## Переменные

---
### Переменные

Переменные в Python:
* не требуют объявления типа переменной (Python - язык с динамической типизацией)
* являются ссылками на область памяти

Правила именования переменных:
* имя переменной может состоять только из букв, цифр и знака подчеркивания
* имя не может начинаться с цифры
* имя не может содержать специальных символов @, $, %

---
### Переменные

```python
In [1]: a = 3

In [2]: b = 'Hello'

In [3]: c, d = 9, 'Test'

In [4]: print(a,b,c,d)
3 Hello 9 Test
```

Обратите внимание, что в Python не нужно указывать, что a это число, а b это строка.

---
### Переменные

Переменные являются ссылками на область памяти. Это можно продемонстрировать с помощью функции ``id()``, которая показывает идентификатор объекта:
```python
In [5]: a = b = c = 33

In [6]: id(a)
Out[6]: 31671480

In [7]: id(b)
Out[7]: 31671480

In [8]: id(c)
Out[8]: 31671480
```

---
### Переменные

С числами у Python есть ещё одна особенность, которая может немного сбить.
Числа от -5 до 256 заранее созданы и хранятся в массиве (списке).
Поэтому при создании числа из этого диапазона фактически создается ссылка на число в созданном массиве.

Это можно проверить таким образом:
```python
In [9]: a = 3

In [10]: b = 3

In [11]: id(a)
Out[11]: 4400936168

In [12]: id(b)
Out[12]: 4400936168

In [13]: id(3)
Out[13]: 4400936168
```

---
### Переменные

У ``a``, ``b`` и числа ``3`` одинаковые идентификаторы.
Все они являются ссылками на существующее число в списке.

Но если сделать то же самое с числом больше 256, идентификаторы у всех разные:
```python
In [14]: a = 500

In [15]: b = 500

In [16]: id(a)
Out[16]: 140239990503056

In [17]: id(b)
Out[17]: 140239990503032

In [18]: id(500)
Out[18]: 140239990502960
```

---
### Переменные

При этом, если сделать присваивание такого вида:
```python
In [19]: a = b = c = 500
```

Идентификаторы будут у всех одинаковые:
```python
In [20]: id(a)
Out[20]: 140239990503080

In [21]: id(b)
Out[21]: 140239990503080

In [22]: id(c)
Out[22]: 140239990503080
```

---
### Имена переменных

В Python есть рекомендации по именованию функций, классов и переменных:
* имена переменных обычно пишутся полностью большими или маленькими буквами
  * DB_NAME
  * db_name
* имена функций задаются маленькими буквами, с подчеркиваниями между словами
  * get_names
* имена классов задаются словами с заглавными буквами, без пробелов
  * CiscoSwitch


---
## Типы данных в Python

---
### Типы данных в Python

В Python есть несколько стандартных типов данных:
* Numbers (числа)
* Strings (строки)
* Lists (списки)
* Dictionaries (словари)
* Tuples (кортежи)
* Sets (множества)
* Boolean

---
### Типы данных в Python

Изменяемые:
* Списки
* Словари
* Множества

Неизменяемые
* Числа
* Строки
* Кортежи

---
### Типы данных в Python

Упорядоченные:
* Списки
* Кортежи
* Строки
* Словари

Неупорядоченные:
* Множества


---
## Числа

---
### Числа

```python
In [1]: 1 + 2
Out[1]: 3

In [2]: 1.0 + 2
Out[2]: 3.0

In [3]: 10 - 4
Out[3]: 6

In [4]: 2**3
Out[4]: 8
```

---
## Строки (Strings)

---
### Строки

Строка в Python:
* последовательность символов, заключенная в кавычки
* неизменяемый упорядоченный тип данных

```python
In [9]: 'Hello'
Out[9]: 'Hello'

In [10]: "Hello"
Out[10]: 'Hello'
```

---
### Строки

```python
In [11]: tunnel = """
   ....: interface Tunnel0
   ....:  ip address 10.10.10.1 255.255.255.0
   ....:  ip mtu 1416
   ....:  ip ospf hello-interval 5
   ....:  tunnel source FastEthernet1/0
   ....:  tunnel protection ipsec profile DMVPN
   ....: """

In [12]: tunnel
Out[12]: '\ninterface Tunnel0\n ip address 10.10.10.1 255.255.255.0\n ip mtu 1416\n ip ospf hello-interval 5\n tunnel source FastEthernet1/0\n tunnel protection ipsec profile DMVPN\n'

In [13]: print(tunnel)

interface Tunnel0
 ip address 10.10.10.1 255.255.255.0
 ip mtu 1416
 ip ospf hello-interval 5
 tunnel source FastEthernet1/0
 tunnel protection ipsec profile DMVPN
```

---
## Форматирование строк

---
### Форматирование строк

Два варианта форматирования строк:
* с оператором ```%``` (более старый вариант)
* методом ```format()``` (новый вариант)
* f-строки - новый вариант, который появился в Python 3.6. 


---
### Форматирование строк с методом format

Пример использования метода format:
```python
In [1]: "interface FastEthernet0/{}".format('1')
Out[1]: 'interface FastEthernet0/1'
```

Специальный символ ```{}``` указывает, что сюда подставится значение, которое передается методу format.
При этом, каждая пара фигурных скобок обозначает одно место для подстановки.

---
### Форматирование строк

С помощью форматирования строк можно выводить результат столбцами.
В форматировании строк можно указывать, какое количество символов выделено на данные.
Если количество символов в данных меньше, чем выделенное количество символов, недостающие символы заполняются пробелами.

---
### Форматирование строк

Например, таким образом можно вывести данные столбцами одинаковой ширины по 15 символов с выравниванием по правой стороне:
```python
In [3]: vlan, mac, intf = ['100', 'aabb.cc80.7000', 'Gi0/1']

In [4]: print("{:>15} {:>15} {:>15}".format(vlan, mac, intf))
            100  aabb.cc80.7000           Gi0/1
```


---
### Форматирование строк

Шаблон для вывода может быть и многострочным:
```python
In [6]: ip_template = '''
   ...: IP address:
   ...: {}
   ...: '''

In [7]: print(ip_template.format('10.1.1.1'))

IP address:
10.1.1.1
```


---
### Форматирование строк

С помощью форматирования строк можно конвертировать числа в двоичный формат:
```python
In [11]: '{:b} {:b} {:b} {:b}'.format(192, 100, 1, 1)
Out[11]: '11000000 1100100 1 1'
```

При этом по-прежнему можно указывать дополнительные параметры, например, ширину столбца:
```python
In [12]: '{:8b} {:8b} {:8b} {:8b}'.format(192, 100, 1, 1)
Out[12]: '11000000  1100100        1        1'
```

А также можно указать, что надо дополнить числа нулями, вместо пробелов:
```python
In [13]: '{:08b} {:08b} {:08b} {:08b}'.format(192, 100, 1, 1)
Out[13]: '11000000 01100100 00000001 00000001'
```


---
## Список (List)

---
### Список

Список:
* изменяемый упорядоченный тип данных.
* последовательность элементов, разделенных между собой запятой и заключенных в квадратные скобки.

```python
In [1]: list1 = [10, 20, 30, 77]
In [2]: list2 = ['one', 'dog', 'seven']
In [3]: list3 = [1, 20, 4.0, 'word']
```

---
### Список

Так как список - это упорядоченный тип данных, то, как и в строках, в списках
можно обращаться к элементу по номеру, делать срезы:
```python
In [4]: list3 = [1, 20, 4.0, 'word']

In [5]: list3[1]
Out[5]: 20

In [6]: list3[1::]
Out[6]: [20, 4.0, 'word']

In [7]: list3[-1]
Out[7]: 'word'

In [8]: list3[::-1]
Out[8]: ['word', 4.0, 20, 1]
```

---
### Список

Так как списки изменяемые, элементы списка можно менять:
```python
In [13]: list3
Out[13]: [1, 20, 4.0, 'word']

In [14]: list3[0] = 'test'

In [15]: list3
Out[15]: ['test', 20, 4.0, 'word']
```

---
### Список

Можно создавать и список списков. И, как и в обычном списке, можно обращаться к элементам во вложенных списках:
```python
In [16]: interfaces = [['FastEthernet0/0', '15.0.15.1', 'YES', 'manual', 'up', 'up'],
   ....: ['FastEthernet0/1', '10.0.1.1', 'YES', 'manual', 'up', 'up'],
   ....: ['FastEthernet0/2', '10.0.2.1', 'YES', 'manual', 'up', 'down']]

In [17]: interfaces[0][0]
Out[17]: 'FastEthernet0/0'

In [18]: interfaces[2][0]
Out[18]: 'FastEthernet0/2'

In [19]: interfaces[2][1]
Out[19]: '10.0.2.1'
```

---
### Список

Функция len возвращает количество элементов в списке:

```python
In [1]: items = [1, 2, 3]

In [2]: len(items)
Out[2]: 3
```

А функция sorted сортирует элементы списка по возрастанию и возвращает новый список с отсортированными элементами:

```python
In [1]: names = ['John', 'Michael', 'Antony']

In [2]: sorted(names)
Out[2]: ['Antony', 'John', 'Michael']
```

---
## Словарь (Dictionary)

---
### Словарь (ассоциативный массив, хеш-таблица)

* изменяемый упорядоченный тип данных 
* данные в словаре - это пары ```ключ: значение```
* доступ к значениям осуществляется по ключу, а не по номеру, как в списках
* словари упорядочены в порядке добавления данных
* так как словари изменяемы, то элементы словаря можно менять, добавлять, удалять
* ключ должен быть объектом неизменяемого типа:
 * число
 * строка
 * кортеж
* значение может быть данными любого типа

---
### Словарь

Пример словаря:
```python
london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

london = {
        'id': 1,
        'name':'London',
        'it_vlan':320,
        'user_vlan':1010,
        'mngmt_vlan':99,
        'to_name': None,
        'to_id': None,
        'port':'G1/0/11'
}
```

---
### Словарь

Для того, чтобы получить значение из словаря, надо обратиться по ключу, таким же образом, как это было в списках, только вместо номера будет использоваться ключ:
```python
In [1]: london = {'name': 'London1', 'location': 'London Str'}

In [2]: london['name']
Out[2]: 'London1'

In [3]: london['location']
Out[3]: 'London Str'
```

---
### Словарь

Аналогичным образом можно добавить новую пару ключ:значение:
```python
In [4]: london['vendor'] = 'Cisco'

In [5]: print(london)
{'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
```

---
### Словарь

В словаре в качестве значения можно использовать словарь:
```python
london_co = {
    'r1' : {
    'hostname': 'london_r1',
    'location': '21 New Globe Walk',
    'vendor': 'Cisco',
    'model': '4451',
    'ios': '15.4',
    'ip': '10.255.0.1'
    },
    'r2' : {
    'hostname': 'london_r2',
    'location': '21 New Globe Walk',
    'vendor': 'Cisco',
    'model': '4451',
    'ios': '15.4',
    'ip': '10.255.0.2'
    },
    'sw1' : {
    'hostname': 'london_sw1',
    'location': '21 New Globe Walk',
    'vendor': 'Cisco',
    'model': '3850',
    'ios': '3.6.XE',
    'ip': '10.255.0.101'
    }
}
```

---
### Словарь

Получить значения из вложенного словаря можно так:
```python
In [7]: london_co['r1']['ios']
Out[7]: '15.4'

In [8]: london_co['r1']['model']
Out[8]: '4451'

In [9]: london_co['sw1']['ip']
Out[9]: '10.255.0.101'
```

---
### Словарь

Функция sorted сортирует ключи словаря по возрастанию и возвращает
новый список с отсортированными ключами:

```python
In [1]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [2]: sorted(london)
Out[2]: ['location', 'name', 'vendor']
```

---
## Кортеж (Tuple)

---
### Кортеж

Кортеж - это неизменяемый упорядоченный тип данных.

Кортеж в Python - это последовательность элементов, которые разделены между собой запятой и заключены в скобки.

Грубо говоря, кортеж - это список, который нельзя изменить. То есть, в кортеже есть только права на чтение. Это может быть защитой от случайных изменений.

---
### Кортеж

Создать пустой кортеж:
```python
In [1]: tuple1 = tuple()

In [2]: print(tuple1)
()
```

Кортеж из одного элемента (обратите внимание на запятую):
```python
In [3]: tuple2 = ('password',)
```

---
### Кортеж

Кортеж из списка:
```python
In [4]: list_keys = ['hostname', 'location', 'vendor', 'model', 'IOS', 'IP']

In [5]: tuple_keys = tuple(list_keys)

In [6]: tuple_keys
Out[6]: ('hostname', 'location', 'vendor', 'model', 'IOS', 'IP')
```

К объектам в кортеже можно обращаться, как и к объектам списка, по порядковому номеру:
```python
In [7]: tuple_keys[0]
Out[7]: 'hostname'
```

---
### Кортеж

Но так как кортеж неизменяем, присвоить новое значение нельзя:
```python
In [8]: tuple_keys[1] = 'test'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-9-1c7162cdefa3> in <module>()
----> 1 tuple_keys[1] = 'test'

TypeError: 'tuple' object does not support item assignment
```

---
## Множество (Set)

---
### Множество

Множество - это изменяемый неупорядоченный тип данных. В множестве всегда содержатся только уникальные элементы.

Множество в Python - это последовательность элементов, которые разделены между собой запятой и заключены в фигурные скобки.

---
### Множество

С помощью множества можно легко убрать повторяющиеся элементы:
```python
In [1]: vlans = [10, 20, 30, 40, 100, 10]

In [2]: set(vlans)
Out[2]: {10, 20, 30, 40, 100}

In [3]: set1 = set(vlans)

In [4]: print(set1)
{40, 100, 10, 20, 30}
```

---
### Полезные методы для работы с множествами

---
### ```add()```

Метод __```add()```__ добавляет элемент во множество:
```python
In [1]: set1 = {10,20,30,40}

In [2]: set1.add(50)

In [3]: set1
Out[3]: {10, 20, 30, 40, 50}
```

---
### ```discard()```

Метод __```discard()```__ позволяет удалять элементы, не выдавая ошибку, если элемента в множестве нет:
```python
In [3]: set1
Out[3]: {10, 20, 30, 40, 50}

In [4]: set1.discard(55)

In [5]: set1
Out[5]: {10, 20, 30, 40, 50}

In [6]: set1.discard(50)

In [7]: set1
Out[7]: {10, 20, 30, 40}
```

---
### ```clear()```

Метод __```clear()```__ очищает множество:
```python
In [8]: set1 = {10,20,30,40}

In [9]: set1.clear()

In [10]: set1
Out[10]: set()
```

---
### Операции с множествами

Множества полезны тем, что с ними можно делать различные операции и находить объединение множеств, пересечение и так далее.

Объединение множеств можно получить с помощью метода __```union()```__ или оператора __```|```__:
```python
In [1]: vlans1 = {10,20,30,50,100}
In [2]: vlans2 = {100,101,102,102,200}

In [3]: vlans1.union(vlans2)
Out[3]: {10, 20, 30, 50, 100, 101, 102, 200}

In [4]: vlans1 | vlans2
Out[4]: {10, 20, 30, 50, 100, 101, 102, 200}
```

---
### Операции с множествами

Пересечение множеств можно получить с помощью метода __```intersection()```__ или оператора __```&```__:
```python
In [5]: vlans1 = {10,20,30,50,100}
In [6]: vlans2 = {100,101,102,102,200}

In [7]: vlans1.intersection(vlans2)
Out[7]: {100}

In [8]: vlans1 & vlans2
Out[8]: {100}
```


---
## Преобразование типов

---
## Преобразование типов

В Python есть несколько полезных встроенных функций, которые позволяют преобразовать данные из одного типа в другой.

---
### ```int()```

```int()``` - преобразует строку в int:
```python
In [1]: int("10")
Out[1]: 10
```

С помощью функции int можно преобразовать и число в двоичной записи в десятичную (двоичная запись должна быть в виде строки) 
```python
In [2]: int("11111111", 2)
Out[2]: 255
```

---
### ```bin()```

Преобразовать десятичное число в двоичный формат можно с помощью ```bin()```:
```python
In [3]: bin(10)
Out[3]: '0b1010'

In [4]: bin(255)
Out[4]: '0b11111111'
```

---
### ```hex()```

Аналогичная функция есть и для преобразования в шестнадцатеричный формат:
```python
In [5]: hex(10)
Out[5]: '0xa'

In [6]: hex(255)
Out[6]: '0xff'
```

---
### ```list()```

Функция ```list()``` преобразует аргумент в список: 
```python
In [7]: list("string")
Out[7]: ['s', 't', 'r', 'i', 'n', 'g']

In [8]: list({1,2,3})
Out[8]: [1, 2, 3]

In [9]: list((1,2,3,4))
Out[9]: [1, 2, 3, 4]
```

---
### ```set()```

Функция ```set()``` преобразует аргумент в множество: 
```python
In [10]: set([1,2,3,3,4,4,4,4])
Out[10]: {1, 2, 3, 4}

In [11]: set((1,2,3,3,4,4,4,4))
Out[11]: {1, 2, 3, 4}

In [12]: set("string string")
Out[12]: {' ', 'g', 'i', 'n', 'r', 's', 't'}
```

Эта функция очень полезна, когда нужно получить уникальные элементы в последовательности.

---
### ```tuple()```

Функция ```tuple()``` преобразует аргумент в кортеж: 
```python
In [13]: tuple([1,2,3,4])
Out[13]: (1, 2, 3, 4)

In [14]: tuple({1,2,3,4})
Out[14]: (1, 2, 3, 4)

In [15]: tuple("string")
Out[15]: ('s', 't', 'r', 'i', 'n', 'g')
```

Это может пригодиться в том случае, если нужно получить неизменяемый объект.

---
### ```str()```

Функция ```str()``` преобразует аргумент в строку: 
```python
In [16]: str(10)
Out[16]: '10'
```

